<?xml version="1.0" encoding="UTF-8"?>
<!-- **************************************************************************
.... For copyright and licensing terms, see the file named COPYING.
.... **************************************************************************
.-->
<?xml-stylesheet href="docbook-xml.css" type="text/css"?>

<refentry id="console-terminal-emulator">

<refmeta xmlns:xi="http://www.w3.org/2001/XInclude">
<refentrytitle>console-terminal-emulator</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class="manual">user commands</refmiscinfo>
<refmiscinfo class="source">nosh</refmiscinfo>
<xi:include href="version.xml" />
</refmeta>

<refnamediv>
<refname>console-terminal-emulator</refname>
<refpurpose>emulate a real terminal using a pseudo-terminal</refpurpose>
</refnamediv>

<refsynopsisdiv>
<cmdsynopsis>
<command>console-terminal-emulator</command>
<arg choice='opt'>--linux</arg>
<arg choice='opt'>--sco</arg>
<arg choice='opt'>--freebsd</arg>
<arg choice='opt'>--netbsd</arg>
<arg choice='opt'>--decvt</arg>
<arg choice='opt'>--vcsa</arg>
<arg choice='opt'>--inverted</arg>
<arg choice='req'><replaceable>directory</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>

<refsection><title>Description</title>

<para>
<command>console-terminal-emulator</command> is a utility that expects file descriptor 4 to be the back end (called "master side" in older documentation) of a pseudo-terminal and the <envar>TTY</envar> environment variable to be the full device filename of the front end (called "slave side" in older documentation).
(<citerefentry><refentrytitle>pty-allocate</refentrytitle><manvolnum>1</manvolnum></citerefentry> can be used to set this process state up.)
</para>

<para>
First it sets up the various files in <filename><replaceable>directory</replaceable>/</filename>, opening the input FIFO for reading and the display buffers for reading and writing.
The FIFOs are created unconditionally, and opened in non-blocking mode.
The display buffers are created if they do not exist.
</para>

<para>
It then enters a loop where it simultaneously:
</para>

<itemizedlist>

<listitem>
<para>
processes all data received from the pseudo-terminal back end as terminal output, handling printing characters, control characters, escape sequences, and control sequences.
</para>
</listitem>

<listitem>
<para>
processes all input events from the input FIFO, sending terminal character and escape sequences to the back end.
</para>
</listitem>

</itemizedlist>

<para>
It finishes when the back end signals hangup (i.e. when the line discipline would set modem control lines on a real serial device to signal hangup because the last front-end file descriptor is closed) and there are no more received data to output.
At termination, it unlinks the file for the front end, and erases the display as if by a Clear Display control sequence.
</para>

</refsection>

<refsection><title>Files</title>

<para>
The files used in <filename><replaceable>directory</replaceable>/</filename>, are described in <citerefentry><refentrytitle>user-vt</refentrytitle><manvolnum>5</manvolnum></citerefentry>.
</para>

<para>
The <arg choice='plain'>--vcsa</arg> command line option enables the creation of and output to the <filename><replaceable>directory</replaceable>/vcsa</filename> file.
It is normally ignored.
The terminal emulator does not recognize nor handle CSI sequences that deal with 8-bit character set switching.
</para>

</refsection>

<refsection><title>Security</title>

<para>
<command>console-terminal-emulator</command> requires no superuser privileges and is designed to be run entirely under the aegis of a dedicated unprivileged user account.
It only requires write and search access to <filename><replaceable>directory</replaceable>/</filename> and need not have owner access to it.
Conversely, only the emulator process needs write access to <filename><replaceable>directory</replaceable>/</filename>, as it is the only thing expected to create files there.
</para>

<para>
All created display buffer files have permissions rw-r-----.
All created input FIFO files have permissions rw--w----.
All display buffer files and the input FIFO file have their group IDs explicitly set to the effective GID of the emulator process.
The emulator process itself has owner access to these files, and their owner ID is the effective UID of the emulator process.
</para>

<para>
Usually <filename><replaceable>directory</replaceable>/</filename> will be set-group-ID to a group different to the effective group ID of the emulator process.
Changing the groups of the display buffer files and input FIFO file to the effective group ID of the emulator process thus distinguishes group access to those files in particular, allowing one to add ordinary users to the effective GID of the emulator process in order to give them direct realizer access to the emulated terminal without (thereby) granting them (group) access to anything else in <filename><replaceable>directory</replaceable>/</filename>.
</para>

<para>
Erasing the display buffer files at (non-abend) termination ensures that (absent system backups, log-structured filesystems, and low-level data recovery) old terminal display content cannot be read out of a display buffer.
For best results, place these files on a temporary filesystem, set whatever options the temporary filesystem has (if any) for erasing backing storage at unmount, and exclude the temporary filesystem from backups.
</para>

</refsection>

<refsection><title>Terminal output</title>

<para>
<command>console-terminal-emulator</command> emulates the character sequence processing logic of a hardware terminal, taking the data received from the back end of the pseudo-terminal and translating them into modifications to the screen buffer data files.
</para>

<para>
All character data are first decoded from UTF-8 to a stream of Unicode code points.
The decoding is directly from UTF-8 to the code points; in particular, UTF-16 is not employed as an intermediary step.
If a UTF-8 sequence decodes to one of the reserved code points used for UTF-16, no special treatment is given, and the code point is treated as any other.
</para>

<para>
The decoder has to do something with invalid UTF-8 encodings, including overlong and incomplete character sequences.
Whatever code point they decode to, such characters are not processed as control characters or as parts of control/escape sequences.
They abort any control/escape sequence that they interrupt, and if not incomplete encodings they are printed as ordinary printing characters even if they are the code points for control characters.
This behaviour should not be relied upon, and programs should not send such UTF-8 sequences to a terminal.
</para>

<refsection><title>Control character processing</title>

<para>
Characters in the "Cc" ("Other, Control") Unicode code point category (a.k.a. "C0" and "C1" characters) are control characters.
They are always processed, even in the middle of escape or control sequences.
All control characters are no-ops except for the following:
</para>

<variablelist>
<varlistentry>
<term><code>CR</code></term>
<listitem><para>Carriage return.  Move to column 0.</para></listitem>
</varlistentry>
<varlistentry>
<term><code>NEL</code></term>
<listitem><para>Newline.  Move to column 0 and one row down.</para></listitem>
</varlistentry>
<varlistentry>
<term><code>LF</code>, <code>VT</code>, <code>FF</code>, and <code>IND</code></term>
<listitem><para>Linefeed/Vertical tab/Index.  Move one row down, remaining in the current column.</para></listitem>
</varlistentry>
<varlistentry>
<term><code>RI</code></term>
<listitem><para>Reverse index.  Move one row up, remaining in the current column.</para></listitem>
</varlistentry>
<varlistentry>
<term><code>TAB</code></term>
<listitem><para>Horizontal tab.  Move to the next tabstop, or the last column.</para></listitem>
</varlistentry>
<varlistentry>
<term><code>BS</code></term>
<listitem><para>Backspace.  Nondestructively move to the previous column, stopping at the first column.</para></listitem>
</varlistentry>
<varlistentry>
<term><code>DEL</code></term>
<listitem><para>Delete.  Delete the character at the cursor position, moving the remainder of the row to the left and padding the final column with a space.</para></listitem>
</varlistentry>
<varlistentry>
<term><code>HTS</code></term>
<listitem><para>Horizontal tab set.  Set a tabstop at the current column.</para></listitem>
</varlistentry>
<varlistentry>
<term><code>CAN</code></term>
<listitem><para>Cancel.  Cancel any control/escape sequence currently in progress.</para></listitem>
</varlistentry>
<varlistentry>
<term><code>ESC</code></term>
<listitem><para>Escape.  Cancel any control/escape sequence currently in progress and begin an escape sequence.</para></listitem>
</varlistentry>
<varlistentry>
<term><code>CSI</code></term>
<listitem><para>Control sequence introducer.  Cancel any control/escape sequence currently in progress and begin a control sequence.</para></listitem>
</varlistentry>
</variablelist>

<note>
<code>BPH</code> is a no-op because the terminal emulator does not have enough information about word breaks or context to handle soft hyphenation.
<code>CCH</code> is a no-op because ECMA-48 leaves it unspecified what the "data preceding it in the data stream" are, and thus it is possible to interpret this in several ways, from BS plus ECH 1 (that only considers printable output as "preceding data") to CAN (because control sequences are data, too).
</note>

</refsection>

<refsection><title>Escape sequences</title>

<para>
Escape sequences are multiple-character sequences comprising:
</para>
<itemizedlist>
<listitem><para>
the ESC character, an optional intermediate character in the range U+0020 to U+002F, and a single final character in the range U+0040 to U+007E.
</para><para>
Most such escape sequences for real terminals are ISO 2022 character set switching sequences, which the terminal emulator has no need of since it uses UTF-8 natively, and so does not support.
The only supported escape sequences are:
</para>
<variablelist>
<varlistentry>
<term><para>DECALN</para></term>
<listitem><para>
the DEC VT extension that fills the display with the letter "E" as a screen alignment test
</para></listitem>
</varlistentry>
<varlistentry>
<term><para>S7C1T</para></term>
<listitem><para>
set the terminal emulator to send C1 characters in control sequences encoded with the ECMA-48 7-bit extensions (as below)
</para></listitem>
</varlistentry>
<varlistentry>
<term><para>S8C1T</para></term>
<listitem><para>
set the terminal emulator to send C1 characters in control sequences as plain single C1 code points (but UTF-8 encoded)
</para></listitem>
</varlistentry>
</variablelist>
</listitem>
<listitem><para>
the ESC character and a single final character in the range U+0040 to U+005F.
</para><para>
This is the two-character 7-bit mechanism of ECMA-48 section 5.
It is strictly speaking unneeded given that the terminal emulator is 8-bit clean and employs UTF-8 as standard.
The entire U+0080 to U+009F control character range is accessible via this mechanism.
So <code>NEL</code> can be emitted as either the single character U+0085 or as the two-character sequence U+001B U+0045.
(Of course, U+0085 encodes to two characters in UTF-8.)
Similarly, <code>CSI</code> can be emitted as either the single character U+009B or as the two-character sequence U+001B U+005B.
</para></listitem>
</itemizedlist>

</refsection>

<refsection><title>Control sequences</title>

<para>
Per ECMA-35 and ECMA-48, control sequences are multiple-character sequences comprising the CSI character followed by parameter characters in the range U+0030 to U+003F followed optionally by an intermediate character in the range U+0020 to U+002F and terminated by a single final character in the range U+0040 to U+007E.
</para>

<para>
Parameters comprise the digits, semi-colon (U+003B), and colon (U+003A), forming up to 16 semi-colon separated sub-sequences; with an initial character in the range U+003C to U+003F denoting a DEC vendor-private control sequence that is an extension to ECMA-48.
Each sub-sequence is up to 16 colon separated digit sequences.
More than 16 parameters or sub-parameters simply causes trailing ones to be discarded.
As an extension to DEC, the terminal allows vendor-private characters anywhere in the parameter character sequence, rather than only in the initial position, ignoring all but the last one.
However, this is largely to simplify implementation and should not be relied upon.
</para>

<para>
The digit sequences are parameters to the action, and zero-length digit sequences are a parameter with the value zero (or, in some cases, 1 or 2).
In most cases, a control sequence with N parameters is equivalent to N such control sequences in order each with one of the parameters.
</para>

<para>
ISO 8613-6/ITU T.416 SGR colour extensions make use of this mechanism, with colour values being encoded as sub-parameters behind a leading 38 or 48 sub-parameter.
That standard explicitly states in section 13.1.8 that "Pe" values are separated by character "3/10" (i.e. U+003A).
Such SGR sequences are unambiguous, since it is not possible to mistake a sub-parameter specifying a colour value for an SGR attribute code: CSI <code>1;4;38:5:14;48:2:0:224:3:7m</code>.
</para>

<para>
As extensions, the row and column counts to the DTTerm DECSLPP 8 control sequence can also be expressed using sub-parameters.
</para>

<para>
As explained at length in the <citerefentry><refentrytitle>console-control-sequence</refentrytitle><manvolnum>1</manvolnum></citerefentry> user manual, the RIS control sequence has been proscribed for decades.
This terminal emulator implements the DECSTR (Soft Terminal Reset) control sequence, which should always be used instead of RIS.
</para>

<refsection><title>SCO control sequences</title>

<para>
There are two control sequences that are peculiar to this terminal emulator: like DECSM and DECRM are variants of the ECMA-48 standard SM and RM using the <quote><code>?</code></quote> intermediate character; so SCOSM and SCORM are variants using the <quote><code>=</code></quote> intermediate character, which set and reset pseudo-SCO private modes that are peculiar to the SCO-like natures of the Linux/FreeBSD kernel terminal emulators.
</para>
<note>
SCO's use of the <quote><code>=</code></quote> intermediate character for its own private control sequences is shown in the SCO <citerefentry><refentrytitle>screen</refentrytitle><manvolnum>HW</manvolnum></citerefentry> user manual.
Most of those control sequences listed therein, except those relating to cursor glyph shape, do not match the terminal emulator's architecture.
(There is no overscan, nor VGA CRTC, nor swappable 7-bit graphics character set, for example.)
</note>
<para>
Pseudo-SCO private modes:
</para>
<variablelist>
<varlistentry>
<term>1</term>
<listitem><para>
This is so-called "square" mode.
If it is off, all Unicode characters classified as "full-width" or "wide" have an extra space printed after them.
This is for the benefit of realizers that have oblong cells that cannot hold full-width or wide glyphs.
It defaults to on, where no such special processing occurs.
</para></listitem>
</varlistentry>
<varlistentry>
<term>2</term>
<listitem><para>
DEC function keys mode.
The default for this is on, which enables the sending of function keys using DECFNK control sequences.
If it is off, the ECMA-48 standard FNK control sequence is used to send function keys instead of DECFNK.
</para><note>
This only applies to function keys, specifically; not to <keycap>PF1</keycap> to <keycap>PF1</keycap> on the calculator keypad, which are not encoded with DECFNK, nor to other calculator and editing keys that are encoded with DECFNK.
</note></listitem>
</varlistentry>
<varlistentry>
<term>3</term>
<listitem><para>
SCO function keys mode.
The default for this is on, which enables the sending of function keys using SCOFNK control sequences.
If it is off, either DECFNK or the ECMA-48 standard FNK control sequence is used to send function keys instead of SCOFNK, according to the setting of the DEC function keys mode.
</para></listitem>
</varlistentry>
<varlistentry>
<term>4</term>
<listitem><para>
Teken function keys mode.
The default for this is on, which enables the sending of function keys using the peculiar mess of SCOFNK and DECFNK control sequences that the teken library has ended up with, as long as SCO function keys mode is also on.
If either it or SCO function keys mode is off, either DECFNK or the ECMA-48 standard FNK control sequence is used to send function keys, according to the setting of the DEC function keys mode.
</para><note>
It is not possible to tell <command>console-terminal-emulator</command> to switch from Teken mode into a pure SCOFNK-only mode.
This is not desirable functionality, as SCOFNK is best avoided.
</note></listitem>
</varlistentry>
</variablelist>

</refsection>

</refsection>

<refsection><title>Colours and attributes</title>

<para>
The terminal emulator maintains a current set of character attributes, a 24-bit RGB foregrond colour, and a 24-bit RGB background colour.
These are combined with character code points when writing to the character cells of each screen buffer.
Each character cell thus has its own, independent, attributes and 24-bit foreground and background colours.
</para>

<refsection><title>How indexed and direct colours are implemented</title>

<para>
The 8 ECMA-48 standard colours set by the SGR control sequences 30&#x2013;37 and 40&#x2013;47, and the 8 AIXTerm colours set by the SGR control sequences 90&#x2013;97 and 100&#x2013;107, map from their 3-bit RGB colours to 24-bit RGB in the conventional manner; which is mostly an RGB 1-bit value mapping to an RGB 8-bit value 127 (standard colours being "dark") or 255 (AIXTerm colours being "bright") when set on and to 0 when set off.
Special exceptions are made for bright black (which would be the same as dark black otherwise) mapping to #7F7F7F and dark white (which would in turn be the same as bright black) mapping to #BFBFBF; and for dark blue mapping to #4B0082 ("Web Indigo").
</para>

<para>
The terminal emulator also supports the ISO 8613-6/ITU T.416 SGR colour extensions, that are often misattributed to xterm:
</para>
<itemizedlist>
<listitem>
<para>
The indexed colour extension (SGR 38:5 and SGR 48:5) has the conventional mapping of 16 "standard" colours, a 24 value grayscale, and a 6&#x00D7;6&#x00D7;6 colour cube.
</para><note>
Colours #000000 and #FFFFFF occur three times each in this conventional map, and the saturated reds and greens occur twice.
</note>
</listitem>
<listitem>
<para>
The RGB direct colour extension (SGR 38:2 and SGR 48:2) simply sets the 24-bit RGB values directly.
</para>
</listitem>
</itemizedlist>

</refsection>

<refsection><title>Erasure</title>

<para>
When characters or lines are deleted (resulting in erased characters or lines being scrolled in), or characters or lines or the screen are explicitly erased, the background colour used for the "filler" that is placed in the newly blanked cells defaults to the current background colour.
This is "background colour erase" and is the default for DEC VT520 terminals as well as the only option on Linux and BSD kernel virtual terminals.
By changing the "DECECM" private mode setting, it can be switched to "screen colour erase", which uses the <emphasis>default</emphasis> terminal background colour (as set by SGR 0 and SGR 49) rather than the current one.
</para>

<para>
Erasure is not the same as writing a space with the screen/background colour.
Writing SPC is affected by the current attribute; and whilst boldface, italic, and faint have no effect on a SPC glyph (it having no foreground pixels), underline and reverse video do.
Erasure always has all attributes set off, and thus erased cells are never underlined or on reverse video.
</para>
<note>
For why this matters, see the explanation of <code>faulty_inverse_erase</code> in <citerefentry><refentrytitle>TerminalCapabilities</refentrytitle><manvolnum>3</manvolnum></citerefentry>.
</note>

</refsection>

<refsection><title>Screen mode ("dark"/"light")</title>

<para>
The <arg choice='plain'>--inverted</arg> command line option determines the initial state of the "DECSCNM" private mode setting, defaulting to off (i.e. "dark").
Use this for a default colour pair akin to a Sun SPARC machine's virtual terminal console, or GUI terminal emulators.
</para>
<note>
Exactly how this takes effect depends from what realizer is being used.
This is a separate flag in the Unicode output buffer, left up to realizers to handle.
Commonly, realizers will XOR it with the reverse video attribute, inverting the sense of reverse video for the whole screen.
However, for other choices, see the explanation of <code>faulty_inverse_erase</code> in <citerefentry><refentrytitle>TerminalCapabilities</refentrytitle><manvolnum>3</manvolnum></citerefentry> for what other terminal emulators do with the DECSCNM flag.
</note>

</refsection>

</refsection>

<refsection><title>Printing characters</title>

<para>
All other characters are "printing" characters.
</para>

<para>
Characters in the "Cf" ("Other, Format") and "Mn" ("Mark, Non-spacing") Unicode code point categories are simply discarded.
</para>
<note>
This includes U+00AD (soft hyphen).
See the discussion of the BPH control character.
</note>

<para>
Characters in the "Me" ("Mark, Enclosing") Unicode code point category overstrike the character at the current cursor position without advancing.
</para>

<para>
All other printing characters are printed as-is, using the currently set attributes, foreground colour, and background colour.
</para>

<refsection><title>Pending line wrap, and automatic scrolling</title>

<para>
After each character is printed, the cursor position is advanced.
</para>

<para>
By default, the emulator has automatic right margins turned on.
Conceptually, automatic right margins means that writing a character in the last column automatically returns to the first column and moves down a row, a line wrap.
If automatic right margins are turned off, writing a character in the last column does not move down a row or return to the first column.
In practice, things are slightly more complex if automatic margins are turned on.
Rather than a wrap happening there and then when the character is written to the last column, instead a pending wrap is flagged.
If the cursor is then explicitly moved, the pending wrap is cancelled.
Otherwise, when the next graphic is to be printed the pending wrap is enacted immediately beforehand.
</para>

<para>
The purpose of pending wrap is to allow full-screen TUI programs to write right up to the lower-right-hand corner without scrolling the screen.
Programs must be aware of and careful about its effect.
In the pending state, the terminal cursor is in a different position to where an application would have expected it to immediately wrap to; and using relative cursor motions in that state, including BackSpace and Next Line, needs to account for this.
</para>

<para>
By default, the emulator also has scrolling turned on, so that moving down from the last row scrolls the buffer up and moving up from the first row scrolls the buffer down.
If scrolling is turned off, moving down from the last row or moving up from the first row have no effect.
Scrolling only applies to cursor advancement by printing characters or the Newline, Index, or Reverse Index control characters.
It does not apply to cursor motion control sequences.
</para>

</refsection>

</refsection>

</refsection>

<refsection><title>Terminal input</title>

<para>
Terminal input operates in terms of a stream of input events, comprising Unicode characters or special keys.
The terminal emulator converts events received via the input FIFO into appropriate escape sequences.
</para>

<orderedlist>
<listitem><para>
Null messages, system keys, consumer device keys, and session switches are ignored by the terminal emulator.
For system and consumer device keys, this is because of a lack of appropriate escape sequences and control sequences for representing them.
</para></listitem>
<listitem><para>
Pasted and non-pasted UCS-4 character inputs are UTF-8 encoded and sent through to the terminal line discipline as terminal input.
Accelerated UCS-4 characters are sent as if non-pasted, and prefixed with ESC.
</para></listitem>
<listitem><para>
Extended keys and function keys are translated into their equivalent (input) control sequences and sent through the terminal line discipline as terminal input.
</para></listitem>
<listitem><para>
Mouse position events that change position, and mouse button events, are translated into their equivalent mouse reports (when enabled) and sent through the terminal line discipline as terminal input.
</para></listitem>
<listitem><para>
If bracketed paste has been switched on, the control sequence denoting end of paste is sent before any non-pasted UCS-4 character, any generated mouse report, any extended key control sequence, or any function key control sequence.
If bracketed paste has been switched off, the control sequence denoting start of paste is sent before any pasted UCS-4 character.
If a pasted UCS-4 character is ESC or CSI, the control sequence denoting end of paste is sent afterward.
This breaks up any pasted control sequences and prevents them from themselves matching any control sequence, including the end of paste control sequence.
</para></listitem>
</orderedlist>

<refsection><title>The abstract keyboard</title>

<para>
The terminal emulator has no dealing in keyboard maps and exactly how keystrokes translate to Unicode characters; which are the province of a realizer.
</para>

<para>
The terminal emulator has no dealing in keyboard modifier state tracking; nor, similarly, does it deal in using modifiers to change dual-mode keypads.
It has no dealings in numlock, capslock, shiftlock and these are not part of the abstract keyboard that is used in the input protocol.
Rather, dealing with this is entirely and solely within the remits of realizers.
For capslock, numlock, and shiftlock, the interactions of the locks and shifts is handled before the input stream is translated into the abstract keyboard.
</para>

<para>
Consequently, for the calculator keypad keys and the cursor/editing keypad keys on the abstract keyboard there are exactly two behaviours: "application mode" and "normal mode".
There are no sub-states of "normal mode" controlled by <keycap>NumLock</keycap>, albeit that in "normal mode" whatever the realizer transmits as an accompanying modifier state may be reflected in generated control sequences using the DEC VT augmentations to DECFNK employed by the VT420 onwards.
(Numeric lock is a function internal to most keyboard hardwares <emphasis>anyway</emphasis> on PS/2 and USB keyboards, with many keyboards sending different scan codes according to the value of the NumLock status LED.
Dealing with it lies in the part of the system that speaks to hardware.)
These sub-modes are provided by realizers and their various keyboard mapping systems, and numlock and the associated shifting are handled before the input stream is translated into the abstract keyboard.
</para>

<para>
Realizers also perform any substitution of <keycap>PF1</keycap> to <keycap>PF5</keycap> on the calculator keypad (which are distinct, extended, keys) for the <keycap>F1</keycap> to <keycap>F5</keycap> function keys.
This is a substitution that originates with DEC VTs, where at reset <keycap>F1</keycap> to <keycap>F5</keycap> were in a "local" mode and did not transmit characters, resulting in applications developers relying upon the calculator keypad keys instead, and hence terminal emulator softwares performing the same substtution for application compatibility.
(In later model DEC VTs these function keys could all be reconfigured to "host mode" and would transmit DECFNK control sequences like any other function key.)
The input protocol distinguishes the function keys from the calculator keypad keys, and a message denoting <keycap>F1</keycap> to <keycap>F5</keycap> denotes those function keys in their "host" mode, not the calculator keypad keys.
</para>

</refsection>

<refsection><title>Control sequences for mouse</title>

<para>
The DEC status reports report that a locator is always present and available, and that it is a mouse device.
</para>

<para>
Two mouse protocols are supported, the xterm Private Mode #1006 protocol and the DEC VT Locator protocol.
These correspond to the <code>ttymouse=sgr</code> and <code>ttymouse=dec</code> settings in <command>vim</command>, respectively.
These are superior to the unsupported xterm Private Mode #9 ("xterm.X10"), #1005 ("xterm.UTF-8"), and #1015 ("urxvt") protocols, for several reasons including avoiding encoding ambiguities and display dimension limits, and supersede them.
</para>

<para>
In the DECPM #1006 protocol, the click-only (DECPM #1000), button motion (DECPM #1002), and all events (DECPM #1003) modes are all available.
The mouse grabber mode (DECPM #1001) is not.
</para>

<para>
In the DEC VT Locator protocol, only character co&#xD6;rdinates are available, the terminal emulator having no dealings in displays; they being the province of a realizer and possibly not even being pixel-addressible.
</para>

</refsection>

<refsection><title>Control sequences for keyboard</title>

<para>
The DEC status reports report that a keyboard is always present, with an unknown country layout.
</para>

<para>
Extended keys and function keys cause the terminal emulator to send control sequences through the line discipline to terminal input.
What control sequences are sent depends from what emulation type the terminal emulator is set to: SCO, Linux, FreeBSD, NetBSD, or DEC VT.
No emulated terminal type defines control sequences for all keys, or distinct control sequences where it does define them.
</para>

<itemizedlist>
<listitem>

<para>
DEC VTs only define control sequences for function keys from 1 to 20 and have no defined control sequences for function keys outwith that range.
These function keys, and keys on the editing keypad, are encoded as the DECFNK control sequence.
In particular, note that function keys <keycap>F1</keycap> to <keycap>F5</keycap> have documented DECFNK numbers (given in the VT420 and VT525 programmers' references), should a realizer actually send those keys.
</para>

<para>
DEC VTs employ SS3 sequences for the <keycap>PF1</keycap> to <keycap>PF5</keycap> keys on the calculator keypad.
Structurally, a <emphasis>single shift</emphasis> cannot carry parameterized modifier information.
(XTerm is faulty in this regard.)
</para>

</listitem>
<listitem>

<para>
The SCO Unix Multiscreen kernel virtual terminal defines SCOFNK control sequences for function keys from 1 to 48.
These are peculiar, ambiguous, and difficult for applications to correctly parse (because they clash with some control sequences, such as CBT, defined by other terminal type families.)
See the SCO <citerefentry><refentrytitle>keyboard</refentrytitle><manvolnum>HW</manvolnum></citerefentry> user manual for a complete list.
</para>

<itemizedlist>
<listitem>
<para>
<keycap>PF1</keycap> to <keycap>PF5</keycap> do not exist in a real SCO KVT, which does not replace <keycap>F1</keycap> to <keycap>F5</keycap>.
</para>
</listitem>
<listitem>
<para>
For <keycap>F1</keycap> to <keycap>F12</keycap> the level 2 shift and control modifiers are encoded into the function key number, and the SCO KVT's original SCOFNK control sequences (which have no parameters) are emitted.
For example:
CSI <code>U</code> is <keycap>F9</keycap>.
CSI <code>^</code> is <keycap>Shift</keycap>+<keycap>Control</keycap>+<keycap>F9</keycap>.
</para>
</listitem>
<listitem>
<para>
For <keycap>F13</keycap> to <keycap>F48</keycap> the SCOFNK control sequences are extended to have parameters.
The function key numbers are used as-is, and the modifiers are instead encoded into the second sub-parameter of the control sequence, in similar form to DECFNK (except zero-based).
The first sub-parameter is a (usually 1) repeat count, again similar to DECFNK.
For example:
CSI <code>1:5U</code> is <keycap>Shift</keycap>+<keycap>Control</keycap>+<keycap>F9</keycap>.
</para>
</listitem>
</itemizedlist>

</listitem>
<listitem>

<para>
The FreeBSD kernel terminal emulator only has function keys from 1 to 12.
It was historically "cons25", whose behaviour closely matched the SCO Unix Multiscreen virtual terminal.
It was then changed from "cons25" to "teken", with the clear intent of being more like DEC VTs and XTerm; and avoiding the problematic SCO function key system.
But only part of the job was done, and the result is a mongrel admixture of DECFNK, SS3, and SCOFNK sequences.
</para>

<itemizedlist>
<listitem>
<para>
<keycap>PF1</keycap> to <keycap>PF4</keycap> (which replace <keycap>F1</keycap> to <keycap>F4</keycap>, of course) always generate SS3 sequences, irrespective of modifiers; and even though they should generate control sequences when application calculator keypad mode is off.
</para>
</listitem>
<listitem>
<para>
Unmodified <keycap>F5</keycap> to <keycap>F12</keycap> are transmitted as DECFNK control sequences, the result of a hardwired map in the Teken library itself.
</para>
</listitem>
<listitem>
<para>
Modified <keycap>F1</keycap> to <keycap>F12</keycap> are transmitted as SCOFNK control sequences, the result of the the <citerefentry><refentrytitle>kbdcontrol</refentrytitle><manvolnum>1</manvolnum></citerefentry> command by default continuing to fill keyboard maps with SCO Unix Multiscreen virtual terminal sequences for function keys.
</para>
</listitem>
</itemizedlist>

</listitem>
<listitem>

<para>
The Linux kernel virtual terminal only defines control sequences for function keys from 1 to 20 and has no defined control sequences for function keys outwith that range.
It employs DECFNK for actual function keys.
</para>

<para>
The Linux KVT employs Linux FNK for the <keycap>PF1</keycap> to <keycap>PF5</keycap> keys on the calculator keypad.
Linux FNK is not conformant with the ECMA-48 rules for control sequences and easy to erroneously confuse with the CSI control sequences for cursor keys, and should be avoided if possible.
</para>

</listitem>
</itemizedlist>

<para>
The terminal emulator may fall back to the ECMA-48 FNK sequences, for function key numbers and modifier chords which have no DECFNK, Linux FNK, or SCOFNK control sequences.
As an extension, the first sub-parameter to FNK encodes modifiers, in similar form to DECFNK (except zero-based).
For examples:
FNK <code>1:0</code> is <keycap>F1</keycap>.
FNK <code>9:5</code> is <keycap>Shift</keycap>+<keycap>Control</keycap>+<keycap>F9</keycap>.
</para>

</refsection>

<refsection><title>Control sequences for pasted input</title>

<para>
The Private Mode #2004 controls whether bracketed paste is switched on.
When it is, sequences of successive pasted characters are bracketed by DECFNK sequences denoting paste on and paste off.
</para>

<para>
To prevent actual pasted character sequences from resembling DECFNK, paste is switched off after every pasted ESC or CSI character.
If the next character is a pasted one, paste will then be switched back on again.
</para>

</refsection>

</refsection>

<refsection><title>Differences from terminals and documented standards</title>

<para>
The terminal emulator does not replicate all features of a real hardware terminal.
Its goal is to provide a workalike for (the TUI parts of the) the virtual terminals that are/were built in to the Linux and BSD operating system kernels.
There is no support for the historical features of real terminal hardwares such as attached printers, page switching, status lines, XON/XOFF modem flow control, programmable function keys, alternative (WYSE/TVI) control/escape sequences, direct auxiliary serial device I/O, and graphics modes.
</para>

<para>
Rather, the terminal emulator is aimed at handling the outputs of TUI programs that use the <quote><code>linux</code></quote> terminal type (for the Linux kernel virtual terminals), the <quote><code>pcvtXX</code></quote> terminal type (for NetBSD kernel virtual terminals), the <quote><code>pccon</code></quote> terminal type (for OpenBSD kernel virtual terminals), or the <quote><code>cons25</code></quote> and <quote><code>teken</code></quote> terminal types (for FreeBSD kernel virtual terminals).
(These are the terminal types set by <citerefentry><refentrytitle>vc-get-terminal</refentrytitle><manvolnum>1</manvolnum></citerefentry>.)
</para>

<para>
The terminal emulator also has no dealing in the things that are the domain of separate realizing tools.
The modular nature of user-space virtual terminals means that the terminal emulator has no knowledge of the actual devices used to realize the terminal, and that there can be zero or many realizers for any given virtual terminal.
There is no support for font definitions, window titles, 256-colour VGA palettes, VGA-specific overscan and underline, VESA power, screen-savers, or multi-mode keypads.
In response to device status report requests, it always responds with fixed information about a set of pseudo-devices.
</para>

<para>
The handling of U+00AD differs from some other terminal emulation programs, which are based upon code written by Markus Kuhn that treats U+00AD unconditionally as an spacing character and explicitly overrides its actual "Mn" (non-spacing) categorization in Unicode.
</para>

<para>
The terminal emulator is 8-bit clean and employs UTF-8 as standard.
Therefore, the terminal emulator has no need for mechanisms to switch 8-bit code pages amongst multiple character sets.
There is no ISO 2022 support.
</para>

<para>
The two-character 7-bit mechanism of ECMA-48 (section 5) is not only present, but is more completely implemented than in several kernel virtual terminal emulators, which usually only implement the 7-bit aliases for CSI and OSC.
</para>

<para>
Both ECMA-48 and the DEC VT520 <citetitle>Video Terminal Programmer Information</citetitle> <citebiblioid>EK-VT520-RM</citebiblioid> reference are straightforward and clear about numeric parameters to cursor motion and screen editing control sequences: a value of 0 is given no special meaning and just means zero rows/columns/repeats/whatever.
There is a full explanation of this in Annex E of ECMA-48:1986 and Annex F of ECMA-48:1991.
Strictly speaking, that is not the behaviour of the Linux or FreeBSD kernel virtual terminal emulators, both of which apply the old 1976 rule; nor is it the behaviour of old DEC VTs.
</para>

<para>
This is one place where the terminal emulator deviates from the aforementioned goal, in favour of conforming with the ECMA-48 standard.
Per the standard, it defaults to zero meaning zero.
It allows this to be controlled with Mode #22, even though using this mode to switch back to the old behaviour was deprecated in ECMA-48:1991.
Nowadays, several common GUI terminal emulators obey the zero-means-zero rule; and at the time of writing this manual it has been <emphasis>34 years</emphasis> since the standard was changed.
</para>

<para>
Neither ECMA-48 nor the DEC VT520 <citetitle>Video Terminal Programmer Information</citetitle> <citebiblioid>EK-VT520-RM</citebiblioid> reference document a quirk of most DEC VT-family emulators: holding line wrap pending.
(This was only ever documented by DEC in internal documentation that was marked "company confidential".)
Actual implementations, including the FreeBSD kernel virtual terminal emulator, have this mechanism.
This is largely undocumented behaviour, but it is behaviour that many programs (including the prompt display of the Z Shell, for example) rely upon.
So it is implemented here.
</para>

<para>
There is a long history of terminal emulators getting ISO 8613-6/ITU T.416 SGR 38 and SGR 48 wrong.
Terminal emulators have variously forgotten the colour space selector in sub-parameter 2 of SGR 38:2 and SGR 48:2.
A long-standing misunderstanding/misreading on the parts of many people has led, moreover, to most programs (from terminfo to the Linux kernel terminal emulator) sending and expecting semi-colons instead of colons, leading to ambiguous SGR sequences: CSI <code>1;4;38;5;14;48;2;0;224;3;7m</code>.
For compatibility, the terminal emulator understands these non-standard and ambiguous control sequences, converting (all remaining) parameters into sub-parameters to resolve ambiguity; but the standard control sequences are preferred.
Please fix this 25-year-old bug if your application has it.
</para>

<para>
There is a degree of variance amongst kernel virtual terminals that can cause problems if the <envar>TERM</envar> environment variable (and hence termcap/terminfo terminal type) used by applications connected to the front end of the terminal does not match the emulation being employed by the terminal emulator.
As explained in <citerefentry><refentrytitle>TERM</refentrytitle><manvolnum>5</manvolnum></citerefentry>, it is an error to use the wrong value for this variable, that does not match the terminal emulator's emulation.
(This is an error called out <ulink url="https://invisible-island.net/ncurses/ncurses.faq.html#xterm_generic">in the XTerm FAQ</ulink>.)
</para>
<note>
<emphasis>None</emphasis> of the emulator modes in this terminal emulator, and none of the kernel virtual terminals being emulated, are the "<code>xterm</code>" terminal type.
</note>

<refsection><title>DEC VT</title>

<para>
This mode is selected by the <arg choice='plain'>--decvt</arg> command-line option.
It matches (a subset of) a DEC VT in its native VT mode.
</para>

<para>
The termcap/terminfo records being matched are the "<code>vt520</code>" terminal type family.
Variances:
</para>

<itemizedlist>
<listitem>
<para>
A DEC VT sets no tabstops in response to the RIS and DECSTR control sequences.
The Linux and FreeBSD kernel terminal emulators both do, however; so for compatibility so too does this terminal emulator.
(As explained earlier, do not use RIS.)
</para>
</listitem>
<listitem>
<para>
A DEC VT does not produce distinct application mode control sequences for the asterisk, minus, and slash graphic keys on the calculator keypad.
This terminal emulator does, giving them SS3-shifted <code>j</code>, <code>m</code>, and <code>o</code> in application calculator keypad mode.
</para>
</listitem>
</itemizedlist>

</refsection>

<refsection><title>SCO</title>

<para>
This mode is selected by the <arg choice='plain'>--sco</arg> command-line option.
With variances as laid out here, it matches the SCO kernel virtual terminal, the FreeBSD KVT with the Teken library in CONS25 mode, the old WSCONS FreeBSD KVT from version 8 and earlier, and (a subset of) a DEC VT in its SCO Console mode.
</para>

<para>
For <keycap>F1</keycap> to <keycap>F12</keycap> the level 2 shift and control modifiers are encoded into the function key number, and the SCO KVT's original SCOFNK control sequences (which have no parameters) are emitted.
For <keycap>F13</keycap> to <keycap>F48</keycap> the SCOFNK control sequences are extended to have parameters.
The function key numbers are used as-is, and the modifiers are instead encoded into the second sub-parameter of the control sequence, in similar form to DECFNK (except zero-based).
The first sub-parameter is a (usually 1) repeat count, again similar to DECFNK.
</para>

<para>
The termcap/terminfo records being matched are the "<code>cons</code>" terminal type family (including its height variants).
Variances:
</para>

<itemizedlist>
<listitem>
<para>
The SCO KVT does not implement application/normal modes for the calculator or cursor keypads.
This terminal emulator does.
</para>
</listitem>
<listitem>
<para>
The SCO KVT does not make a distinction between the calculator keypad keys (with numeric lock off) and the matching editing/cursor keypad keys.
This terminal emulator follows suit in its SCO mode, even though the input protocol actually does.
</para>
</listitem>
<listitem>
<para>
The SCO KVT does not ever produce control sequences for the graphic keys on the calculator keypad (i.e. plus, minus, enter, slash, and asterisk).
It always produces the graphic characters.
This terminal emulator produces SS3-shifted characters when that keypad is in application mode.
</para>
</listitem>
<listitem>
<para>
The SCO KVT always yields the DEL character for the <keycap>Del</keycap> keys on the editing and calculator keypads.
In addition to providing application mode for the calculator keypad, this terminal emulator provides in normal keypad mode the switchable <keycap>Del</keycap> behaviour of a DEC VT (via DEC Private Mode #1037).
</para>
</listitem>
<listitem>
<para>
The SCO KVT always yields the BS character for the <keycap>Backspace</keycap> key on the main keypad.
This terminal emulator provides the switchable <keycap>Backspace</keycap> behaviour of a DEC VT (via DEC Private Mode #67).
</para>
</listitem>
<listitem>
<para>
The SCO KVT does not produce control sequences when calculator keypad keys (in normal mode) or cursor keypad keys are used with the <keycap>Alt</keycap> modifier.
This terminal emulator adds modifier parameters to the CSI control sequences.
</para>
</listitem>
<listitem>
<para>
The SCO KVT does not support equals or (ABNT2) comma on the calculator keypad.
This terminal emulator does, giving them SS3-shifted <code>X</code> and <code>l</code> in application calculator keypad mode.
</para>
</listitem>
<listitem>
<para>
The SCO KVT does not support actual <keycap>F13</keycap> and upwards function keys.
A DEC VT in its SCO Console mode falls back to its native VT mode, using DECFNK, for <keycap>F13</keycap> to <keycap>F20</keycap>.
This terminal emulator instead falls back to an extended SCOFNK mechanism, as described earlier.
</para>
</listitem>
</itemizedlist>

</refsection>

<refsection><title>FreeBSD (Teken)</title>

<para>
This mode is selected by the <arg choice='plain'>--freebsd</arg> command-line option, and is the default when the terminal emulator is compiled for FreeBSD.
With variances as laid out here, it matches the FreeBSD 9 and later kernel virtual terminal, that uses the Teken library, in its native Teken mode.
</para>

<para>
The termcap/terminfo records being matched are the "<code>teken</code>" terminal type family (including its colouring variants).
This is is now the proper terminal type for the FreeBSD kernel virtual terminal.
Importantly, it is <emphasis>not</emphasis> the "<code>xterm</code>" or "<code>cons25</code>" terminal type families; and it is an error to think that Teken is XTerm or even a subset of it.
</para>

<para>
Variances:
</para>

<itemizedlist>
<listitem>
<para>
The FreeBSD KVT does not report modifiers for keys on the editing, cursor, or calculator keypads.
This terminal emulator does.
</para>
</listitem>
<listitem>
<para>
The FreeBSD KVT does not implement application/normal modes for the calculator keypad.
This terminal emulator does.
</para>
</listitem>
<listitem>
<para>
Except for <keycap>Del</keycap>, the FreeBSD KVT does not make a distinction between the calculator keypad keys (with numeric lock off) and the matching editing/cursor keypad keys.
This terminal emulator follows suit in its Teken mode, even though the input protocol actually does.
</para>
</listitem>
<listitem>
<para>
The FreeBSD KVT does not ever produce control sequences for the graphic keys on the calculator keypad (i.e. plus, minus, enter, slash, and asterisk).
It always produces the graphic characters.
This terminal emulator produces SS3-shifted characters when that keypad is in application mode.
</para>
</listitem>
<listitem>
<para>
The FreeBSD KVT always yields the DEL character for the <keycap>Del</keycap> key on the calculator keypad, and always yields DEKFNK for the <keycap>Del</keycap> key on the editing keypad.
In addition to providing application mode for the calculator keypad, this terminal emulator provides in normal keypad mode the switchable <keycap>Del</keycap> behaviour of a DEC VT (via DEC private mode #1037).
</para>
</listitem>
<listitem>
<para>
The FreeBSD KVT always yields the BS character for the <keycap>Backspace</keycap> key on the main keypad.
This terminal emulator provides the switchable <keycap>Backspace</keycap> behaviour of a DEC VT (via DEC Private Mode #67).
</para>
</listitem>
<listitem>
<para>
The FreeBSD KVT does not produce control sequences when calculator keypad keys (in normal mode) or cursor keypad keys are used with the <keycap>Alt</keycap> modifier.
This terminal emulator adds modifier parameters to the CSI control sequences.
</para>
</listitem>
<listitem>
<para>
The FreeBSD KVT does not support equals or (ABNT2) comma on the calculator keypad.
This terminal emulator does, giving them SS3 sequences with final characters <code>X</code> and <code>l</code> in application calculator keypad mode.
</para>
</listitem>
<listitem>
<para>
The FreeBSD KVT does not support the XTerm alternative screen buffer.
This terminal emulator does.
</para>
</listitem>
</itemizedlist>

</refsection>

<refsection><title>NetBSD ("vt100")</title>

<para>
This mode is selected by the <arg choice='plain'>--netbsd</arg> command-line option, and is the default when the terminal emulator is compiled for NetBSD.
With variances as laid out here, it matches the NetBSD kernel virtual terminal in its "vt100" mode.
</para>

<note>
It is a misnomer to name this "vt100", as NetBSD does.
A true DEC VT100 series does not match this emulation.
It did not do ECMA-48 colour, for example.
</note>

<para>
The termcap/terminfo records being matched are the "<code>wsvt</code>" terminal type family (including its height variants).
Variances:
</para>

<itemizedlist>
<listitem>
<para>
The NetBSD KVT does not report modifiers for keys on the editing, cursor, or calculator keypads.
This terminal emulator does.
</para>
</listitem>
<listitem>
<para>
The NetBSD KVT does not implement application/normal modes for the cursor and calculator keypads.
This terminal emulator does.
</para>
</listitem>
<listitem>
<para>
The NetBSD KVT does not make a distinction between the calculator keypad keys (with numeric lock off) and the matching editing/cursor keypad keys.
This terminal emulator follows suit in its NetBSD mode, even though the input protocol actually does.
</para>
</listitem>
<listitem>
<para>
The NetBSD KVT does not ever produce control sequences for the graphic keys on the calculator keypad (i.e. plus, minus, enter, slash, and asterisk).
It always produces the graphic characters.
This terminal emulator produces SS3-shifted characters when that keypad is in application mode.
</para>
</listitem>
<listitem>
<para>
The NetBSD KVT always yields the DEL character for the <keycap>Del</keycap> key on the calculator keypad, and always yields DEKFNK for the <keycap>Del</keycap> key on the editing keypad.
In addition to providing application mode for the calculator keypad, this terminal emulator provides in normal keypad mode the switchable <keycap>Del</keycap> behaviour of a DEC VT (via DEC private mode #1037).
</para>
</listitem>
<listitem>
<para>
The NetBSD KVT always yields the BS character for the <keycap>Backspace</keycap> key on the main keypad.
This terminal emulator provides the switchable <keycap>Backspace</keycap> behaviour of a DEC VT (via DEC Private Mode #67).
</para>
</listitem>
<listitem>
<para>
The NetBSD KVT does not produce control sequences when calculator keypad keys (in normal mode) or cursor keypad keys are used with the <keycap>Alt</keycap> modifier.
This terminal emulator adds modifier parameters to the CSI control sequences.
</para>
</listitem>
<listitem>
<para>
The NetBSD KVT does not support equals or (ABNT2) comma on the calculator keypad.
This terminal emulator does, giving them SS3 sequences with final characters <code>X</code> and <code>l</code> in application calculator keypad mode.
The latter is defined by DEC VTs.
</para>
</listitem>
</itemizedlist>

</refsection>

<refsection><title>Linux</title>

<para>
This mode is selected by the <arg choice='plain'>--linux</arg> command-line option, and is the default when the terminal emulator is compiled for Linux.
</para>

<para>
The termcap/terminfo records being matched are the "<code>linux</code>" terminal type family (including its colouring variants).
Variances:
</para>

<itemizedlist>
<listitem>
<para>
The Linux kernel virtual terminal sends the DECFNK sequences for <keycap>FIND</keycap> and <keycap>SELECT</keycap> for the <keycap>HOME</keycap> and <keycap>END</keycap> keys, rather than the (different) proper control sequences for those keys.
</para>
<para>
This has two major consequences:
If the terminal emulator is in Linux emulation mode, <keycap>HOME</keycap> and <keycap>END</keycap> will not be correctly recognized if the <envar>TERM</envar> environment variable does not also specify "<code>linux</code>"; and if the terminal emulator is in another mode but the <envar>TERM</envar> environment variable is set to "<code>linux</code>", <keycap>FIND</keycap> and <keycap>SELECT</keycap> will be incorrectly recognized and <keycap>HOME</keycap> and <keycap>END</keycap> will not be recognized at all.
</para>
</listitem>
<listitem>
<para>
The Linux KVT does not report modifiers for keys on the editing, cursor, or calculator keypads.
This terminal emulator does.
</para>
</listitem>
<listitem>
<para>
The Linux KVT does not make a distinction between the calculator keypad keys (with numeric lock off) and the matching editing/cursor keypad keys.
This terminal emulator follows suit in its Linux mode, even though the input protocol actually does.
</para>
</listitem>
<listitem>
<para>
The Linux KVT does not ever produce control sequences for the graphic keys on the calculator keypad (i.e. plus, minus, enter, slash, and asterisk).
It always produces the graphic characters.
This terminal emulator produces SS3-shifted characters when that keypad is in application mode.
</para>
</listitem>
<listitem>
<para>
The Linux KVT does not produce control sequences when calculator keypad keys (in normal mode) or cursor keypad keys are used with the <keycap>Alt</keycap> modifier.
This terminal emulator adds modifier parameters to the CSI control sequences.
</para>
</listitem>
<listitem>
<para>
The Linux KVT does not support equals or (ABNT2) comma on the calculator keypad.
This terminal emulator does, giving them SS3 sequences with final characters <code>X</code> and <code>l</code> in application calculator keypad mode.
The latter is defined by DEC VTs.
</para>
</listitem>
</itemizedlist>

</refsection>

</refsection>

<refsection><title>See also</title>

<variablelist>
<varlistentry>
<term>
<citerefentry><refentrytitle>pty-run</refentrytitle><manvolnum>1</manvolnum></citerefentry>
</term>
<listitem>
<para>an I/O pump that pumps data in both directions between the back end of a pseudo-terminal and its own standard I/O</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<citerefentry><refentrytitle>console-control-sequence</refentrytitle><manvolnum>1</manvolnum></citerefentry>
</term>
<listitem>
<para>a utility for emitting a range of useful control sequences</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<citerefentry><refentrytitle>console-multiplexor</refentrytitle><manvolnum>1</manvolnum></citerefentry>
</term>
<term>
<citerefentry><refentrytitle>console-input-method</refentrytitle><manvolnum>1</manvolnum></citerefentry>
</term>
<listitem>
<para>mechanisms that layer on top of a terminal emulator</para>
</listitem>
</varlistentry>
</variablelist>

</refsection>

<refsection><title>Author</title>
<para><author><personname><firstname>Jonathan</firstname> <surname>de Boyne Pollard</surname></personname></author></para>
</refsection>

</refentry>
