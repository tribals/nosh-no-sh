<link rel="Up" href="../index.html" title="nosh Guide" />
<link rel="Stylesheet" type="text/css" href="../guide.css" title="Guide default style" />
<title>sntpclock, taiclock, and fake-hwclock services</title>
<h1 class="Ruled">
The <code>sntpclock</code>, <code>taiclock</code>, <code>taiclockd</code>, and <code>fake-hwclock</code> services
</h1>

<p>
The Bernstein <code>sntpclock</code>, <code>taiclock</code>, and <code>taiclockd</code> tools from clockspeed can be run as services.
These provide a much simpler alternative for keeping a system's clock accurate, to <code>ntpd</code> or even to the likes of <code>chrony</code>.
The <code>fake-hwclock</code> service is an augmentation for use on systems without an actual hardware clock chip, that can be used in conjunction.
</p>

<h2 class="Ruled">
Synchcronizing to external clocks
</h2>

<p>
The <code>sntpclock</code> and <code>taiclock</code> service bundles are mutually exclusive and are ordered to be brought up after the <code>persistent-clock-loaded</code> standard target and before the <code>system-time-synchronized</code> one.
(See the <a href="../commands/service-bundle.xml"><code>service-bundle</code></a> manual page.)
This system is <em>intentionally</em> a simple one that is simpler than the systems that synchronize to multiple external time sources.
Only one time source, SNTP or TAICLOCK, can be used with these services at any given point.
</p>

<p>
By default these two services look for time servers on the anycast IP address 224.0.1.1.
This usually is not present on small-office/home-office networks.
So the service bundles can be hand-configured in the conventional ways with substitute IP addresses in an <code>IPADDR</code> envirment variable stored in an environment variable directory in the conventional place for a service.
This variable can be accessed and modified in the conventional ways:
</p>
<ul>
<li><pre><a href="commands/rcctl.xml">rcctl</a> set sntpclock IPADDR 203.0.113.123</pre></li>
<li><pre>system-control print-service-env sntpclock IPADDR</pre></li>
</ul>

<p>
The <code>sntpclock</code> and <code>taiclock</code> services synchronize once per day.
To see how they will synchronize at the next run, you can simulate the service environment but with <code>clockview</code> instead of <code>clockadd</code> at the end of the pipeline.
For example:
</p>
<blockquote><pre>envdir "`system-control find sntpclock`/service/env" pipe --inwards sh -c 'sntpclock "${IPADDR:-224.0.1.1}"' \| clockview</pre></blockquote>

<h2 class="Ruled">
Providing an external clock to other systems
</h2>

<p>
The <code>taiclockd</code> just serves the current time to other systems via the TAICLOCK protocol, and does not conflict with any of these other services.
</p>

<p>
For each of the network addresses listed as <code>taiclockd_network_addresses</code> in <code>/etc/rc.conf</code> the <a href="../external-formats.html">external formats import subsystem</a> generates a <code>taiclockd@</code><i>address</i> service.
If is no network address setting, it generates <code>taiclockd@::0</code>, serving time to the world.
(To not set up any such taiclockd services at all, the <code>taiclockd_network_addresses</code> setting must exist and be blank.)
</p>
<p class="note">
Note:
This requires the improved Bernstein <code>taiclockd</code> tools from <a href="http://jdebp.uk./Softwares/djbwares/">the djbwares toolset</a>, which can speak TAICLOCK over IPv4.
The original Bernstein <code>taiclockd</code> (retained in the djbwares toolset as <code>taiclock4d</code>) only speaks IPv4.
The improved <code>taiclockd</code> works with combined IPv6-and-IPv4 network stacks, and can serve both IPv6 and IPv4 clients.
</p>

<h2 class="Ruled">
Retaining the date and time over system restarts
</h2>

<p>
The <code>fake-hwclock</code> service simply persists a clock value across system shutdown and reboot.
It does this by simple dint of regularly recording the system clock into a file at approximately hourly intervals whilst the system is running, and updating the system clock from the value in the file (but only if that means adjusting it forwards) in the system startup before the <code>persistent-clock-loaded</code> standard target becomes ready.
</p>

<p>
It does not require any additional toolsets, as it is a very basic implementation of the mechanism using a shell script and the standard <code>date</code> command.
It is designed for systems that have no persistent, battery-powered, clock of their own.
It can be run on systems that do have such hardware, but it will just log errors about the system clock being ahead of its last persisted value (which will be the case because actual battery-powered clock hardware "ticks" forward when the system is powered off).
</p>

<p>
TianoCore EFI firmware provides a similar kind of mechanism, which operating systems such as NetBSD will pick up automatically as their "hardware clock"; but its persistent clock, which it stores in a file in the EFI System Partition, does not "tick" whilst the operating system is running, only when the EFI firmware is in "boot services" mode.
This can result in TianoCore's fake clock becoming weeks, months, or even years behind; which usually causes a warning message at boot time as operating systems sanity-check hardware clock values (against, ironically, datestamps on the root filesystem).
Whilst <code>fake-hwclock</code> does not actually "tick" per se, its persistent clock value does get updated and will not (after a system restart) lag the actual time by such extreme amounts if a system happens to remain up for a long time.
</p>
